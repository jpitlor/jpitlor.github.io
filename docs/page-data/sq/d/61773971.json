{"data":{"allGithubData":{"nodes":[{"data":{"user":{"pinnedItems":{"nodes":[{"name":"jpitlor.github.io","description":"My personal website","homepageUrl":"https://www.pitlor.dev","url":"https://github.com/jpitlor/jpitlor.github.io","object":{"text":"# Personal Website\n\nMy website and resume are generated using Gatsby, Bulma, `react-pdf`, and Contentful.\n\n## Design/Development Process\n\nFor a long time, I was unsure what I wanted my personal website to look like.\nAll I knew was that I wanted it to be elegant. It had to:\n\n- Be easy to find information\n- Have a UI that combines the functionality of the 90s era web with the beauty \n  of the modern web\n- Be **fast**\n- Be easy to update\n  \nIt's no secret that a lot of websites don't check enough of these bullets.\nUnfortunately, every website has to make sacrifices, including mine, but I sought\nto check as many of those bullets as I could.\n\n#### Iteration 1\n\nThe first iteration of my website used [a Bootstrap template](https://github.com/StartBootstrap/startbootstrap-resume)\nas most do, and it was _okay_. At that time, I was an underclassman in college and\ndidn't have a ton to fill out my resume with anyway, so I wasn't concerned that it\nwasn't perfect. At that point, I was happy that it was easily expandable, looked relatively\nclean, and didn't look like a Bootstrap template.\n\n#### Iteration 2\n\nEventually, after I got my first full time job, I realized that while the first iteration \nhad served me well, I was ready for something better. I had been exposed to more of\nthe web development world, and I wanted something that fit my needs better.\n\nWhat helped jump start my transition was a [local meetup](https://clereact.dev/) meeting\nteaching how easy it was to make a website with Gatsby and Contentful. As you'll read, it\nactually is quite easy.\n\n**Information I Wanted on my Website**\n\nAt first, I wasn't _really_ sure what I wanted on my website. Probably my name,\nschool, and contact info, but past that, I just knew having an online presence was good.\nAt this point, I knew I wanted:\n\n- One page that housed the same information as my resume, but presented in a more beautiful\n  way, and with the ability to print as a PDF\n- One page for my musical achievements - my compositions, arrangements, and performances\n\nWhile this didn't directly inform my design choices, I think it's important to document, as\nthe information on the site is the most important part. If the site isn't designed around the\ninformation it's communicating or the services it's providing, users will not enjoy using it.\n\n**Deciding on a Tech Stack**\n\nAs discussed earlier, the initial spark into this project was Gatsby. It isn't necessarily groundbreaking,\nbut I loved how easy it made both information aggregation and server side rendering. I could have used\nNext.js for SSR, and I did on future projects, but the information aggregation sold me.\n\nI also decided to use Contentful for my CMS. There wasn't too much decision making here - \nContentful works well with Gatsby, and is easy to use. I could have probably used others, but\nI didn't need much out of a CMS.\n\n**Deciding on a Design**\n\nThe decision process for a library was relatively short. I wanted a library with pre-made components,\nbut something less clunky than Bootstrap. I investigated several libraries, but landed on [Bulma](https://bulma.io/).\nBulma is clean, has the usual pre-made components, in addition to some other commonly used \ncomponents such as modals and boxes.\n\nIn terms of content, I knew from the beginning I wanted my resume and my music on my website, so I \ndecided it was that simple and kept the site to two pages. One for my resume, and one for my music.\n\nThere was a lot of tinkering involved, but eventually I landed on a design that was elegant enough to\nmeet my standards while still not polluting the information with too much design.\n\n**Deploying/Editing Post Development**\n\nOne of my goals was to make my website as easy as humanly possible to edit after deployed.\nIn my initial approach, using Jekyll, this was easy, but still required making additional commits\nto the code. Now, using Contentful, it's incredibly easy! I edit information, hit rebuild, and\neverything is up to date without touching code. The deployment process is subject to change,\nbut the CMS is a welcome addition.\n\n## Running Locally\n\nTo run locally, copy `.env.example`, and fill out values for the keys. Then,\nit is all runnable via `npm`\n\n    $ cp .env.example .env\n    $ # Fill in values for .env\n    $ npm install\n    $ npm start\n"}},{"name":"homelab-provisioner","description":"Manage homelab resource provisioning with OpenTofu","homepageUrl":"","url":"https://github.com/jpitlor/homelab-provisioner","object":{"text":"# Homelab Provisioner\r\n\r\nThese are OpenTofu files that can provision my GCP project, DNS records, and Proxmox VMs\r\n\r\n# Prerequisites\r\n\r\n- [Google Cloud Platform](https://console.cloud.google.com/) account\r\n  - The name of the project you want to create in GCP\r\n- Machine running [Proxmox](https://www.proxmox.com/en/downloads)\r\n  - URL\r\n  - Account credentials\r\n- [OpenTofu](https://opentofu.org/docs/intro/install/) installed\r\n\r\n# Bootstrap\r\n\r\nFirst, authenticate with Google Cloud. The easiest way to do this is\r\nby installing [the CLI](https://cloud.google.com/sdk/docs/install).\r\n\r\nNext, go into the `bootstrap-1-project` folder, and prepare the variable\r\nfiles.\r\n\r\n```shell\r\ncd bootstrap-1-project\r\ncp .env.example .env\r\ncp terraform.tfvars.example terraform.tfvars\r\n```\r\n\r\nGo into the newly created `.env` and `terraform.tfvars` and change the \r\nparts that say `CHANGEME`. Then, run OpenTofu. This should create the \r\nproject in GCP.\r\n\r\n```shell\r\nsource .env\r\ntofu init\r\ntofu apply\r\n```\r\n\r\nNow, you need to move on to the second half of bootstrapping, creating\r\nthe bucket that will ultimately be used for the main OpenTofu state file\r\n\r\n```shell\r\ncd ../bootstrap-2-project\r\ntofu init\r\ntofu apply\r\ncd ..\r\n```\r\n\r\n# Usage\r\n\r\nFirst, you'll need to fill in the variables\r\n\r\n```shell\r\ncp terraform.tfvars.example terraform.tfvars\r\n```\r\n\r\nGo into the newly created `terraform.tfvars` and update all the\r\nvalues that say `CHANGEME`. Then, simply run:\r\n\r\n```shell\r\nsource .env\r\ntofu init\r\ntofu apply\r\n```\r\n\r\nTODO: Make this happen automatically in Gitea in the nuc\r\n\r\n# Non-managed Resources\r\n\r\n## Windows\r\n\r\nFirst, copy the example unattend file:\r\n\r\n```shell\r\ncp autounattend.example.xml autounattend.xml\r\n```\r\n\r\nThen, look for `CHANGEME-PASSWORD` and replace it with your actual password.\r\nOptionally, look for `fanny-brice` and replace it with the computer name\r\nyou want. Format a USB drive with a [Windows ISO](https://www.microsoft.com/software-download/windows11),\r\nthen add `autounattend.xml` to the flash drive.\r\n\r\nPlug in, turn on, have fun.\r\n\r\n## Linux\r\n\r\nYou should be able to use the `cloud-config.yml` file to configure a Linux\r\nPC, but I'm not researching exact instructions since I don't have any non-server\r\nLinux machines.\r\n\r\n## MacOS \r\n\r\nWhy are you even reading this repo? Just go do things the Apple way and\r\nexperience their beautiful installer\r\n"}},{"name":"homelab-configuration","description":"Ansible role to configure fresh VMs","homepageUrl":"","url":"https://github.com/jpitlor/homelab-configuration","object":{"text":"# Homelab Configurtation\n\nThis is an Ansible playbook and Packer files to configure all of my homelab infrastructure.\n\n## Usage\n\nWhile Ansible is typically a \"push\" model where one commanding server uses SSH to configure\nother computers, it's most convenient for me to use a \"pull\" model where the client computers\ndownload the new configuration and run it themselves. This can be achieved by running:\n\n```shell\nsudo apt-get install ansible\nansible-pull -U https://github.com/jpitlor/homelab-configuration\n```\n\nThen, to make sure the client stays correctly configured in the future, set up a cron job. This\ncommand writes the cron config to a file in the cron.d folder to make sure any updates to the\ncron package don't overwrite this configuration.\n\n```shell\necho \"@daily jpitlor ansible-pull -U https://github.com/jpitlor/homelab-configuration\" > /etc/cron.d/ansible\n```\n\n\nnetsh interface portproxy add v4tov4 listenport=8081 listenaddress=0.0.0.0 connectport=8081 connectaddress=$(wsl hostname -I)\n"}},{"name":"homelab-chart","description":"A Helm chart of containers I self host","homepageUrl":"","url":"https://github.com/jpitlor/homelab-chart","object":{"text":"# Homelab Chart\n\nTo keep my Ansible roles debloated, I've extracted all of the containers I host into this Helm chart.\n"}}]}}}}]}}}